<!doctype html>
<html lang="pt-BR">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Exercícios 4.4 — Criando Threads</title>
    <style>
        :root {
            --bg: #f6f8fb;
            --surface: #fff;
            --border: #dde2eb;
            --text: #1f2937;
            --muted: #6b7280;
            --hover: #e6ecf5;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial, sans-serif;
            color: var(--text);
            background: var(--bg);
        }

        main {
            padding: 14px;
        }

        h3 {
            margin: 0 0 10px;
        }

        .exercise {
            border: 1px dashed var(--border);
            border-radius: 10px;
            padding: 12px;
            margin: 12px 0;
        }

        .options {
            display: grid;
            gap: 8px;
        }

        .option-btn {
            appearance: none;
            border: 1px solid var(--border);
            background: var(--surface);
            padding: 10px 12px;
            border-radius: 10px;
            cursor: pointer;
            text-align: left;
            transition: background-color .15s, border-color .15s, box-shadow .15s;
        }

        .option-btn:hover {
            background: var(--hover);
        }

        .option-btn:focus {
            outline: 2px solid transparent;
            box-shadow: 0 0 0 3px rgba(94, 129, 172, .35);
        }

        .option-btn.correct {
            border-color: #2a9d8f;
            background: rgba(42, 157, 143, .10);
        }

        .option-btn.incorrect {
            border-color: #e76f51;
            background: rgba(231, 111, 81, .10);
        }

        .exercise-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .redo-btn {
            appearance: none;
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--text);
            border-radius: 10px;
            padding: 8px 12px;
            cursor: pointer;
        }

        .redo-btn:hover {
            background: var(--hover);
        }

        .feedback {
            margin-top: 6px;
            color: var(--muted);
        }

        .why {
            margin-top: 6px;
        }

        .why summary {
            cursor: pointer;
            color: var(--muted);
        }

        .explanation {
            margin-top: 6px;
        }
    </style>
</head>

<body>
    <main>
        <h3>Exercícios 4.4 — Criando e Executando Threads</h3>
        <div id="ex-list"></div>
    </main>
    <script>
        const QUESTIONS = [
            {
                prompt: "Quais são as duas formas de criar threads em Java?",
                options: ["Usando new Process() ou new Job()", "Extends Thread ou implements Runnable", "Usando synchronized ou volatile"],
                answerIndex: 1,
                explanation: "Threads podem ser criadas herdando a classe Thread ou implementando a interface Runnable."
            },
            {
                prompt: "Por que 'implements Runnable' é geralmente preferido?",
                options: ["É mais rápido", "Permite que a classe herde de outra classe (Java não suporta herança múltipla)", "Usa menos memória"],
                answerIndex: 1,
                explanation: "Como Java não suporta herança múltipla, usar Runnable permite que sua classe herde de outra classe."
            },
            {
                prompt: "O que acontece se chamar run() diretamente ao invés de start()?",
                options: ["A thread executa normalmente", "A tarefa executa na thread atual, sem criar concorrência", "Ocorre um erro de compilação"],
                answerIndex: 1,
                explanation: "Chamar run() diretamente executa a tarefa na thread atual. Para criar concorrência, deve-se chamar start()."
            },
            {
                prompt: "O método join() faz o quê?",
                options: ["Junta duas threads em uma", "Faz a thread atual esperar pelo término de outra thread", "Interrompe uma thread"],
                answerIndex: 1,
                explanation: "join() permite que uma thread espere pelo término de outra. Ex: t1.join() faz a thread atual esperar t1 terminar."
            },
            {
                prompt: "O que o método yield() faz?",
                options: ["Encerra a thread", "Suspende a execução e permite que outra thread de mesma prioridade execute", "Aumenta a prioridade da thread"],
                answerIndex: 1,
                explanation: "yield() passa o controle para outra thread de mesma prioridade, permitindo alternância de execução."
            }
        ];

        function shuffle(arr) { return arr.map(v => ({ v, r: Math.random() })).sort((a, b) => a.r - b.r).map(o => o.v); }

        function render() {
            const list = document.getElementById('ex-list');
            list.innerHTML = '';
            QUESTIONS.forEach((q) => {
                const ex = document.createElement('div');
                ex.className = 'exercise';
                ex.innerHTML = `
          <h4>${q.prompt}</h4>
          <div class="options"></div>
          <div class="exercise-actions"><button class="redo-btn" type="button">Refazer</button></div>
          <div class="feedback" aria-live="polite"></div>
        `;
                const optsEl = ex.querySelector('.options');
                const fb = ex.querySelector('.feedback');
                const order = shuffle(Array.from({ length: q.options.length }, (_, i) => i));
                optsEl.innerHTML = order.map(i => `<button class="option-btn" data-i="${i}">${q.options[i]}</button>`).join('');
                optsEl.querySelectorAll('.option-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const chosen = Number(btn.getAttribute('data-i'));
                        const correct = chosen === q.answerIndex;
                        ex.querySelectorAll('.option-btn').forEach(b => b.classList.remove('correct', 'incorrect'));
                        btn.classList.add(correct ? 'correct' : 'incorrect');
                        fb.innerHTML = correct ? `Correto! ✅${q.explanation ? `<div class=\"explanation\">${q.explanation}</div>` : ''}` : `Incorreto. <details class=\"why\"><summary>Por quê?</summary><div class=\"explanation\">${q.explanation || 'Releia os conceitos desta subseção.'}</div></details>`;
                    });
                });
                ex.querySelector('.redo-btn').addEventListener('click', () => {
                    const order2 = shuffle(Array.from({ length: q.options.length }, (_, i) => i));
                    optsEl.innerHTML = order2.map(i => `<button class="option-btn" data-i="${i}">${q.options[i]}</button>`).join('');
                    fb.textContent = '';
                    optsEl.querySelectorAll('.option-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const chosen = Number(btn.getAttribute('data-i'));
                            const correct = chosen === q.answerIndex;
                            ex.querySelectorAll('.option-btn').forEach(b => b.classList.remove('correct', 'incorrect'));
                            btn.classList.add(correct ? 'correct' : 'incorrect');
                            fb.innerHTML = correct ? `Correto! ✅${q.explanation ? `<div class=\"explanation\">${q.explanation}</div>` : ''}` : `Incorreto. <details class=\"why\"><summary>Por quê?</summary><div class=\"explanation\">${q.explanation || 'Releia os conceitos desta subseção.'}</div></details>`;
                        });
                    });
                });
                list.appendChild(ex);
            });
        }

        render();
    </script>
</body>

</html>